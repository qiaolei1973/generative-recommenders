# 📊 MovieLens-1M 数据集详解

## 1. 数据集概述

### 基本信息
- **名称**: MovieLens-1M (ml-1m)
- **规模**: 约 100 万条评分记录
- **用户数**: 6,040 位用户
- **电影数**: 3,706 部电影
- **时间跨度**: 2000年前后
- **来源**: GroupLens Research (明尼苏达大学)

### 数据集作用

MovieLens-1M 是推荐系统研究中最经典的基准数据集之一，在本项目中用于：

1. **训练生成式推荐模型** - 学习用户的观影序列模式
2. **评估算法性能** - 对比 HSTU、SASRec、BERT4Rec 等算法
3. **验证技术创新** - 测试 Jagged Tensors、Sampled Softmax 等优化技术
4. **学习和实验** - 为入门开发者提供可复现的实验环境

---

## 2. 原始数据格式

### 2.1 评分数据 (ratings.dat)

**格式**: `UserID::MovieID::Rating::Timestamp`

**示例**:
```
1::1193::5::978300760
1::661::3::978302109
1::914::3::978301968
```

**字段说明**:
- `UserID`: 用户ID (1-6040)
- `MovieID`: 电影ID (1-3952)
- `Rating`: 评分 (1-5星)
- `Timestamp`: Unix时间戳 (秒)

### 2.2 电影信息 (movies.dat)

**格式**: `MovieID::Title::Genres`

**示例**:
```
1::Toy Story (1995)::Animation|Children's|Comedy
2::Jumanji (1995)::Adventure|Children's|Fantasy
3::Grumpier Old Men (1995)::Comedy|Romance
```

**字段说明**:
- `MovieID`: 电影ID
- `Title`: 电影标题（包含年份）
- `Genres`: 电影类型（多个类型用 | 分隔）

**可用类型**:
- Action（动作）
- Adventure（冒险）
- Animation（动画）
- Children's（儿童）
- Comedy（喜剧）
- Crime（犯罪）
- Documentary（纪录片）
- Drama（剧情）
- Fantasy（奇幻）
- Film-Noir（黑色电影）
- Horror（恐怖）
- Musical（音乐剧）
- Mystery（悬疑）
- Romance（爱情）
- Sci-Fi（科幻）
- Thriller（惊悚）
- War（战争）
- Western（西部）

### 2.3 用户信息 (users.dat)

**格式**: `UserID::Gender::Age::Occupation::Zip-code`

**示例**:
```
1::F::1::10::48067
2::M::56::16::70072
3::M::25::15::55117
```

**字段说明**:
- `Gender`: 性别 (M=男性, F=女性)
- `Age`: 年龄段 (1, 18, 25, 35, 45, 50, 56)
- `Occupation`: 职业代码 (0-20)
- `Zip-code`: 邮政编码

---

## 3. 处理后的数据格式

### 3.1 SASRec 格式 (sasrec_format_by_user_*.csv)

经过 `preprocess_public_data.py` 处理后，数据被转换为序列推荐格式。

**格式**: `user_id,sequence_item_ids,sequence_ratings,sequence_timestamps`

**示例**:
```
2424,"1721,1210,1641","4,4,2","974231993,974232016,974232244"
```

**字段说明**:
- `user_id`: 用户ID
- `sequence_item_ids`: 用户观看的电影ID序列（按时间排序）
- `sequence_ratings`: 对应的评分序列
- `sequence_timestamps`: 对应的时间戳序列

### 3.2 数据集划分

数据被划分为三个集合：

#### A. 训练集 (sasrec_format_by_user_train.csv)
- **用途**: 训练模型参数
- **内容**: 每个用户序列的前 N-2 个交互
- **示例**: 用户看了 [电影1, 电影2, 电影3, 电影4, 电影5]
  - 训练数据: [电影1, 电影2, 电影3]

#### B. 验证集 (sasrec_format_by_user_val.csv)
- **用途**: 调整超参数，选择最佳模型
- **内容**: 每个用户序列的倒数第2个交互
- **示例**: 
  - 输入: [电影1, 电影2, 电影3]
  - 目标: 预测 电影4

#### C. 测试集 (sasrec_format_by_user_test.csv)
- **用途**: 评估最终模型性能
- **内容**: 每个用户序列的最后1个交互
- **示例**:
  - 输入: [电影1, 电影2, 电影3, 电影4]
  - 目标: 预测 电影5

---

## 4. 数据集体现的信息

### 4.1 用户行为模式

#### 序列依赖关系
```
用户A: [玩具总动员] → [虫虫特工队] → [怪物公司]
→ 体现: 用户喜欢皮克斯动画电影
```

#### 时间演化
```
用户B: 
2000年1月: [泰坦尼克号] (爱情)
2000年6月: [拯救大兵瑞恩] (战争)
2000年12月: [黑客帝国] (科幻)
→ 体现: 用户兴趣随时间变化
```

#### 评分偏好
```
用户C:
- 动作片平均评分: 4.5
- 爱情片平均评分: 2.8
→ 体现: 用户对不同类型的偏好强度
```

### 4.2 电影特征

#### 类型信息
```
肖申克的救赎: Drama
→ 可以推荐: 阿甘正传 (Drama)
```

#### 时代特征
```
1990s电影: 更多经典剧情片
2000s电影: 更多科幻动作片
```

#### 流行度
```
热门电影: 星球大战、泰坦尼克号 (被很多用户评分)
冷门电影: 独立小众电影 (评分较少)
```

### 4.3 协同过滤信号

#### 用户相似性
```
用户1: [电影A, 电影B, 电影C]
用户2: [电影A, 电影B, 电影D]
→ 用户1和用户2有相似的兴趣
→ 可以将电影D推荐给用户1
```

#### 物品相似性
```
看过《星球大战》的用户也看了：
- 《星际迷航》 (80%)
- 《黑客帝国》 (75%)
- 《终结者》 (70%)
```

---

## 5. 数据统计特征

### 5.1 基本统计

```
总评分数: 1,000,209
平均每用户评分: 165.6 部电影
平均每电影评分: 269.9 个用户
评分分布:
  5星: 34.2%
  4星: 27.1%
  3星: 20.5%
  2星: 11.4%
  1星: 6.8%
```

### 5.2 长尾分布

#### 用户活跃度
```
高活跃用户 (>200评分): 20%
中等活跃 (50-200评分): 50%
低活跃 (<50评分): 30%
```

#### 电影流行度
```
热门电影 (>500评分): 5%
中等流行 (100-500评分): 25%
冷门电影 (<100评分): 70%
```

### 5.3 稀疏性

```
评分矩阵稀疏度: 95.5%
(只有4.5%的 用户-电影 对有评分)

这意味着：
- 大量的用户-电影组合没有交互
- 推荐系统需要从稀疏数据中学习
```

---

## 6. 数据集的挑战

### 6.1 冷启动问题

```
新用户: 没有历史评分 → 难以推荐
新电影: 没有用户评分 → 难以被推荐
```

### 6.2 数据稀疏性

```
6040用户 × 3706电影 = 22,392,240 可能的评分
实际评分: 1,000,209 (4.5%)
→ 95.5% 的数据是缺失的
```

### 6.3 长尾分布

```
少数热门电影占据大部分评分
→ 冷门电影难以被推荐
→ 需要平衡流行度和个性化
```

### 6.4 时间动态性

```
用户兴趣随时间变化
电影流行度随时间变化
→ 需要考虑时间因素
```

---

## 7. HSTU 如何利用这些信息

### 7.1 序列建模
```
HSTU 通过 Transformer 架构：
- 捕捉用户观影序列的顺序关系
- 学习短期兴趣（最近看的电影）
- 学习长期偏好（一贯喜欢的类型）
```

### 7.2 注意力机制
```
Multi-Head Attention 自动学习：
- 哪些历史电影对预测下一部更重要
- 电影之间的隐含关系（如类型相似性）
```

### 7.3 时间建模
```
相对位置偏置：
- 最近的交互权重更高
- 考虑时间间隔的影响
```

### 7.4 高效训练
```
Sampled Softmax：
- 不需要对所有3706部电影计算分数
- 只对128个采样电影计算
- 训练速度提升29倍
```

---

## 8. 实际使用示例

### 8.1 训练数据流程

```python
# 1. 读取处理后的数据
train_data = pd.read_csv('tmp/ml-1m/sasrec_format_by_user_train.csv')

# 2. 每一行是一个用户的序列
# user_id: 2424
# sequence_item_ids: "1721,1210,1641"
# sequence_ratings: "4,4,2"
# sequence_timestamps: "974231993,974232016,974232244"

# 3. 模型训练
# 输入: [1721, 1210]
# 目标: 预测 1641
# 输入: [1721, 1210, 1641]
# 目标: 预测下一个（从验证集获取）
```

### 8.2 评估流程

```python
# 测试集
test_data = pd.read_csv('tmp/ml-1m/sasrec_format_by_user_test.csv')

# 对每个用户：
# 输入: 历史序列
# 预测: Top-10 电影
# 评估: 真实的下一部电影是否在 Top-10 中 (HR@10)
```

---

## 9. 数据集的局限性

### 9.1 时间过时
```
数据来自2000年左右
- 电影库不包含近期电影
- 用户行为模式可能已变化
```

### 9.2 规模限制
```
只有100万评分
- 相比真实工业系统（数十亿交互）较小
- 某些复杂模式可能无法体现
```

### 9.3 单一领域
```
只有电影推荐
- 不包含其他类型（音乐、商品等）
- 跨域推荐无法测试
```

### 9.4 评分偏差
```
用户主动评分
- 可能只评价喜欢或不喜欢的电影
- 不代表所有观看行为
```

---

## 10. 扩展：MovieLens-20M 和 MovieLens-3B

### MovieLens-20M
```
评分数: 20,000,263
用户数: 138,493
电影数: 27,278
优势: 更大规模，更能体现算法的扩展性
```

### MovieLens-3B (合成数据)
```
评分数: 3,000,000,000 (30亿)
通过分形扩展生成
优势: 测试超大规模推荐系统的 scaling law
```

---

## 11. 快速检查数据

### 查看数据文件
```bash
# 查看原始数据
head tmp/ml-1m/ratings.dat

# 查看处理后的训练数据
head tmp/ml-1m/sasrec_format_by_user_train.csv

# 统计数据量
wc -l tmp/ml-1m/sasrec_format_by_user_*.csv
```

### 验证数据完整性
```bash
# 检查文件是否存在
ls -lh tmp/ml-1m/

# 应该看到:
# - ratings.dat
# - movies.dat
# - users.dat
# - sasrec_format_by_user_train.csv
# - sasrec_format_by_user_val.csv
# - sasrec_format_by_user_test.csv
```

---

## 12. 总结

MovieLens-1M 数据集为本项目提供了：

✅ **真实的用户行为数据** - 反映实际观影模式
✅ **序列信息** - 支持序列推荐算法
✅ **时间信息** - 可以建模时间动态性
✅ **评分信息** - 反映用户偏好强度
✅ **元数据** - 电影类型、用户属性等
✅ **基准性能** - 可以与其他算法对比
✅ **适中规模** - 适合学习和实验

通过这个数据集，HSTU 模型能够：
- 学习用户的序列行为模式
- 预测用户下一步可能感兴趣的电影
- 在 HR@10 指标上比 SASRec 提升 8.6%

---

**数据集下载**: 运行 `python3 preprocess_public_data.py` 自动下载和处理

**参考资料**: [MovieLens 官方网站](https://grouplens.org/datasets/movielens/)

**最后更新**: 2026-01-12

